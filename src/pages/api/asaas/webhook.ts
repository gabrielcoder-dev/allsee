import type { NextApiRequest, NextApiResponse } from 'next';
import { createClient } from '@supabase/supabase-js';
import { atualizarStatusCompra } from '@/lib/utils';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // Aceitar apenas POST
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method Not Allowed' });
  }

  try {
    const event = req.body;

    console.log('üì• Webhook recebido do Asaas:', JSON.stringify(event, null, 2));

    // O Asaas envia eventos no formato: { event: 'PAYMENT_RECEIVED', payment: {...} }
    const eventType = event.event;
    const payment = event.payment;

    // Verificar se √© um evento de pagamento v√°lido
    if (!payment) {
      console.warn('‚ö†Ô∏è Webhook sem dados de pagamento');
      return res.status(400).json({ error: 'Dados de pagamento n√£o encontrados' });
    }

    // Obter orderId do externalReference
    const orderId = payment.externalReference;
    
    if (!orderId) {
      console.warn('‚ö†Ô∏è Webhook sem externalReference (orderId)');
      return res.status(400).json({ error: 'externalReference (orderId) n√£o encontrado' });
    }

    const paymentId = payment.id;
    const paymentStatus = payment.status;
    const billingType = payment.billingType; // PIX, BOLETO, CREDIT_CARD
    const installments = payment.installments || 1; // N√∫mero total de parcelas
    const installmentNumber = payment.installment; // N√∫mero da parcela atual (se houver)
    const value = payment.value;

    // Identificar tipo de pagamento
    const paymentTypeName = 
      billingType === 'PIX' ? 'PIX' :
      billingType === 'BOLETO' ? 'BOLETO' :
      billingType === 'CREDIT_CARD' ? 'CART√ÉO DE CR√âDITO' :
      billingType || 'DESCONHECIDO';

    console.log(`üìã Processando webhook para pedido ${orderId}:`, {
      eventType,
      paymentId,
      paymentStatus,
      billingType: paymentTypeName,
      installments,
      installmentNumber,
      valor: value,
      isParcelado: installments > 1,
    });

    // Verificar se o pedido existe
    const { data: order, error: orderError } = await supabase
      .from('order')
      .select('id, status, preco')
      .eq('id', orderId)
      .single();

    if (orderError || !order) {
      console.error('‚ùå Pedido n√£o encontrado:', orderId, orderError);
      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
    }

    console.log(`üì¶ Pedido encontrado:`, {
      id: order.id,
      statusAtual: order.status,
      valorPedido: order.preco,
    });

    // Processar eventos de pagamento confirmado/recebido
    // Eventos que indicam pagamento confirmado:
    // - PAYMENT_RECEIVED
    // - PAYMENT_CONFIRMED
    // - Status: RECEIVED, CONFIRMED
    const isPaymentConfirmed = 
      eventType === 'PAYMENT_RECEIVED' ||
      eventType === 'PAYMENT_CONFIRMED' ||
      paymentStatus === 'RECEIVED' ||
      paymentStatus === 'CONFIRMED';

    if (isPaymentConfirmed) {
      // Verificar se deve atualizar o status baseado no tipo de pagamento
      let shouldUpdateStatus = false;
      let updateReason = '';

      // PIX: Sempre atualiza quando pagar (pagamento √∫nico)
      if (billingType === 'PIX') {
        shouldUpdateStatus = true;
        updateReason = 'Pagamento PIX recebido';
      }
      // BOLETO: Sempre atualiza quando pagar (pagamento √∫nico)
      else if (billingType === 'BOLETO') {
        shouldUpdateStatus = true;
        updateReason = 'Boleto pago';
      }
      // CART√ÉO DE CR√âDITO: 
      // - Se n√£o √© parcelado (1 parcela), atualiza sempre
      // - Se √© parcelado, atualiza quando for a primeira parcela (entrada)
      else if (billingType === 'CREDIT_CARD') {
        if (installments === 1 || !installmentNumber || installmentNumber === 1) {
          shouldUpdateStatus = true;
          updateReason = installments > 1 
            ? `Primeira parcela do cart√£o recebida (${installmentNumber}/${installments})`
            : 'Pagamento com cart√£o confirmado';
        } else {
          // Parcela subsequente - n√£o atualiza status, mas registra
          console.log(`‚ÑπÔ∏è Parcela ${installmentNumber}/${installments} do cart√£o recebida para pedido ${orderId} - Status n√£o alterado`);
          return res.status(200).json({ 
            success: true,
            message: `Parcela ${installmentNumber}/${installments} recebida - Status n√£o alterado`,
            orderId,
            status: order.status,
            installmentNumber,
            installments
          });
        }
      }
      // Outros tipos de pagamento: atualiza sempre
      else {
        shouldUpdateStatus = true;
        updateReason = `Pagamento ${paymentTypeName} recebido`;
      }

      if (shouldUpdateStatus) {
        // Verificar se o pedido j√° est√° pago (evitar atualiza√ß√µes desnecess√°rias)
        if (order.status === 'pago') {
          console.log(`‚ÑπÔ∏è Pedido ${orderId} j√° est√° com status "pago" - Atualizando apenas ID do pagamento`);
        } else {
          // Atualizar status do pedido para "pago" usando a fun√ß√£o existente
          try {
            await atualizarStatusCompra(orderId, 'pago');
            console.log(`‚úÖ Status do pedido ${orderId} atualizado para "pago" - Motivo: ${updateReason}`);
          } catch (updateError: any) {
            console.error('‚ùå Erro ao atualizar status do pedido:', updateError);
            return res.status(500).json({ 
              error: 'Erro ao atualizar status do pedido',
              details: updateError.message 
            });
          }
        }

        // Tentar atualizar tamb√©m o ID do pagamento no pedido (se a coluna existir)
        try {
          await supabase
            .from('order')
            .update({ 
              asaas_payment_id: paymentId,
              updated_at: new Date().toISOString()
            })
            .eq('id', orderId);
        } catch (updatePaymentIdError: any) {
          // Ignorar erro se a coluna n√£o existir
          console.warn('‚ö†Ô∏è Aviso: n√£o foi poss√≠vel salvar asaas_payment_id (coluna pode n√£o existir)');
        }

        console.log(`‚úÖ Pedido ${orderId} processado com sucesso!`, {
          tipo: paymentTypeName,
          motivo: updateReason,
          statusAnterior: order.status,
          statusNovo: 'pago'
        });
        
        return res.status(200).json({ 
          success: true,
          message: 'Pagamento confirmado e pedido atualizado',
          orderId,
          status: 'pago',
          paymentType: paymentTypeName,
          reason: updateReason
        });
      }
    }

    // Para outros eventos, apenas registrar
    console.log(`‚ÑπÔ∏è Evento processado mas n√£o requer atualiza√ß√£o de status:`, {
      eventType,
      paymentStatus,
      billingType: paymentTypeName,
      orderId,
    });

    return res.status(200).json({ 
      success: true,
      message: 'Webhook recebido com sucesso',
      orderId,
      eventType,
      paymentStatus,
      paymentType: paymentTypeName
    });

  } catch (error: any) {
    console.error('‚ùå Erro ao processar webhook do Asaas:', error);
    return res.status(500).json({
      error: 'Erro ao processar webhook',
      details: error.message
    });
  }
}
